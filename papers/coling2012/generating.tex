\section{Generation of referring expressions}\label{sec:gre}

In linguistics, a \emph{referring expression} (RE) is an expression that 
unequivocally identifies the intended target to the interlocutor, from a set of possible distractors.  
For example, if we intend to identify a certain animal $d$ from a set of pets, the expression 
``the dog'' will be an RE if $d$ is the only dog in the set, and if we are confident
that our interlocutor will identify $d$ as a dog. 

The generation of referring expressions (GRE)  is a key task of most natural 
language generation (NLG) systems (e.g.,~\cite[Section 5.4]{dale2000}). 
Depending on the information available to the NLG system, certain objects might 
not be associated with an identifier which can be easily recognized by the user. 
In those cases, the system will have to generate a, possibly complex, description that contains 
enough information so that the interlocutor will be able to identify the intended referent.

The generation of referring expressions is a well developed field in automated natural language generation.
Building upon Dale and Reiter's foundational work~\cite{dale89cooking,Dale1995},
various proposals have investigated the generation of different kinds of referring expressions 
such as relational expressions (``the blue ball next to the cube''~\cite{dale91:_gener_refer_expres_invol_relat}),
reference to sets (``the two small cubes''~\cite{Stone2000}), or more expressive logical connectives (``the 
blue ball not on top of the cube''~\cite{deemter02:_gener_refer_expres}).

REs involving relations, in particular, have
received increasing attention recently; especially in the context of
spatial referring expressions in situated generation (e.g.~\cite{kelleher06:_increm_gener_of_spatial_refer}), where it is
particularly natural to use expressions such as ``the ball next to the box''.  However, the classical algorithm by~\cite{dale91:_gener_refer_expres_invol_relat} was shown to be unable to generate satisfying REs in practice (see the 
analysis over the \emph{cabinet corpus} in~\cite{viethen06:_algor_for_gener_refer_expres}).  Furthermore, the Dale
and Haddock algorithm and many of its successors (such as~\cite{kelleher06:_increm_gener_of_spatial_refer}) are vulnerable to
the problem of \emph{infinite regress}, where the algorithm jumps back
and forth between generating descriptions for two related individuals
infinitely, as in ``the book on the table which supports a book on the
table \ldots''

In~\cite{arec:refe08,arec:usin11} new, low complexity algorithms have been proposed for the generation 
of relational REs (including references to sets) that eliminate the risk of infinite regression. 
These algorithms are based on different variations of the partition refinement algorithms of~\cite{paig:thre87}.
Given a knowledge base containing the information about a situation, the information is 
interpreted as a labeled graph.  The algorithm, then, partitions the graph nodes into sets that can 
be described by the same description.  This partition is successively refined (while possible) till the target 
is the only element fitting the description of its part.  The existence of a RE for the target will 
depend, on the one hand, on the information available in the input knowledge base, and on the other 
on the expressive power of the formal language used to describe the elements of the different 
parts in the partition (e.g., whether the REs can contain negations, or relational information). 

The idea of using a formal language to describe the information that an RE should convey has been mentioned
already in~\cite{Krahmer2003,gardent07:_gener_bridg_defin_descr}.  In~\cite{arec:refe08,arec:usin11} the 
combination of partition refinement algorithms and different formal languages is used to classify existing 
GRE approaches in an expressiveness hierarchy.  For instance, the classical Dale and Reiter algorithms
compute purely conjunctive formulas; \cite{deemter02:_gener_refer_expres} extends this language by
adding the other propositional connectives, whereas~\cite{dale91:_gener_refer_expres_invol_relat} extends it by
allowing existential quantification.

The partition algorithms presented in~\cite{arec:refe08,arec:usin11} effectively
compute REs for all individuals in the domain at the same time; and ensure termination with a formula of 
the formal language chosen that uniquely describes the target, if such a formula exists (i.e., if the 
formal language chosen is expressive enough to uniquely identify the target in the input model). In~\cite{arec:refe08}
it is shown that the partition algorithm using the description language \el as formal language is capable of generating 67\% of 
the relational REs in the~\cite{viethen06:_algor_for_gener_refer_expres} dataset. This is in sharp contrast with the analysis 
done in~\cite{viethen06:_algor_for_gener_refer_expres} over the cabinet corpus, of algorithms based in Dale and Reiter's original proposal.    

In this article we continue this line of research.  The partition algorithms described in~\cite{arec:refe08,arec:usin11} require an 
ordered lists of the properties that can be used to described the objects in the scenario, and the coverage results reported over Viethen and 
Dale's cabinet corpus means that \emph{some ordering} produces a reasonably wide coverage.  In other words, it has been shown that partition algorithms have the capacity of producing REs similar to those produces by human subjects, provided a suitable ordering over relations appearing 
in the input scene. In this article we will discuss how this order can actually be learnt from corpora.  

Our goal is actually twofold. First we show how we can add non-determinism to the partition algorithms, by replacing the fixed ordering 
over the properties of the input scenario by a \emph{probability of use} of each property, and modifying the algorithm accordingly.  
In this way, each call to the algorithm can produce different REs for the same input scenario and target.  We will then show that given suitable corpora of RE (like the GRE3D7 corpora discussed in~\cite{viet:gene11}) we can estimate these probability of use so that REs are generated with a probability distribution that matches the ones found in the corpora.  

The rest of the paper is structured as follows. In Section~\ref{sec:algorithm} we introduce the technical details of the 
partition algorithms presented in~\cite{arec:refe08,arec:usin11} and show how to introduce non-determinism using 
the probability of use of the properties in the input scenario.  In this section, we assume that these probabilities are provided as 
input to the algorithm. In Section~\ref{sec:learning}, we show how to estimate the 
probability of use of a property from training data. Given corpora consisting of pairs (scenario, target) together with the REs used to 
describe the target in each case, we propose a method to compute the probability of use of each property for each scenario, and use a machine learning approach to generalize these properties to new targets and scenarios not appearing in the corpora. 

Preliminary testing of the resulting algorithms shows that there is still one factor missing to property account for the REs found in corpora: overspecification.  Partition algorithms only allow a mild form of over-specification in the REs produced.  We discuss this in Section~\ref{sec:overspecification} and propose a slight modification that generate the kind of over-specification found in corpora. 

Section~\ref{sec:evaluation} evaluation presents a cuantitative evaluation of our REG algorithm and we discusses INTERESTING EXAMPLES. Section~\ref{sec:discussion} discusses previous work, applications and motivations of our proposal. Section~\ref{sec:conclusion} concludes and points to future work.

